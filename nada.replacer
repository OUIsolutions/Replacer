[{
		"action":	"write",
		"source":	"src/user_data.c",
		"content":	"//\n// Created by mateusmoutinho on 27/07/23.\n//\n\nconst int  SEARCH = 0;\nconst int  REPLACE = 1;\n\ntypedef struct UserData{\n    int action;\n    char *first_token;\n    int first_token_size;\n    char *second_token;\n    int second_token_size;\n    char *source;\n    int type_of_source;\n    bool ignore_strings;\n    bool case_sensitive;\n}UserData;\n\nUserData * extract_user_informations(){\n    UserData *user = (UserData*)malloc(sizeof(UserData));\n    //extracting informations\n\n\n    user->action = interface.ask_option( &interface,\"type the action\",\"search | replace\");\n\n    if(user->action == SEARCH){\n        user->first_token = interface.ask_string(&interface,\"type the element to search\",CLI_NOT_TRIM);\n    }\n    if(user->action == REPLACE){\n        user->first_token = interface.ask_string(&interface,\"type the element that will be replaced\",CLI_NOT_TRIM);\n        user->second_token = interface.ask_string(&interface,\"type the element to replace\",CLI_NOT_TRIM);\n        user->second_token_size = (int)strlen(user->second_token);\n    }\n    user->first_token_size  = (int) strlen(user->first_token);\n\n    user->ignore_strings = interface.ask_option( &interface,\"do you want to ignore strings?\",\"no | yes\");\n    user->case_sensitive = interface.ask_option( &interface,\"case sensitive?\",\"no | yes\");\n\n    if(!user->case_sensitive){\n        CTextStack *first_token = newCTextStack_string(user->first_token);\n        free(user->first_token);\n        stack.self_lower(first_token);\n        user->first_token = strdup(first_token->rendered_text);\n        stack.free(first_token);\n    }\n\n    while(true){\n        if(user->action == REPLACE){\n            user->source = interface.ask_string(&interface,\"type the folder/file to replace\",CLI_TRIM);\n        }\n        else{\n            user->source = interface.ask_string(&interface,\"type the folder/file to search\",CLI_TRIM);\n        }\n\n        //means its the current dir\n        if(strcmp(user->source,\".\") == 0){\n            free(user->source);\n            user->source = dtw_get_current_dir();\n        }\n\n        user->type_of_source =dtw_entity_type(user->source);\n        if(user->type_of_source == DTW_NOT_FOUND){\n            CTextStack *s = newCTextStack_string_empty();\n            stack.format(s,\"%s is not an valid source\\n\",user->source);\n            interface.warning(&interface,s->rendered_text);\n            free(user->source);\n            stack.free(s);\n            continue;\n        }\n        break;\n    }\n    return user;\n}\n\nvoid user_data_free(UserData *user){\n    free(user->source);\n    free(user->first_token);\n    if(user->action == REPLACE){\n        free(user->second_token);\n    }\n    free(user);\n\n}"
	}, {
		"action":	"write",
		"source":	"src/search.c",
		"content":	"//\n// Created by mateusmoutinho on 27/07/23.\n//\n\nvoid execute_search_for_file(UserData *user_data,char *filename){\n\n    char *content = dtw_load_string_file_content(filename);\n    if(!content){\n        return;\n    }\n    CTextStack * element = newCTextStack_string(content);\n\n    CTextStack *mensage = newCTextStack_string_empty();\n    stack.format(mensage,\"file: \\\"%s\\\" lines:[\",filename);\n\n    free(content);\n\n    long current_line = 0;\n    bool found = false;\n    bool inside_string = false;\n    char string_breaker_char = '\\0';\n\n    for(int i =0; i < element->size; i++){\n        char current_char = element->rendered_text[i];\n\n        if(current_char =='\\n'){\n            current_line+=1;\n        }\n\n        if(user_data->ignore_strings){\n\n            //means its inside and its an scape scape\n            if(inside_string  == true && current_char =='\\\\'){\n                i+=1;\n                continue;\n            }\n\n            //means its inside string\n            if(inside_string  == true && current_char != string_breaker_char){\n                continue;\n            }\n\n\n            //means its an start of string\n            if(inside_string == false && (current_char == '\"' || current_char == '\\'') ){\n                string_breaker_char = current_char;\n                inside_string = true;\n                continue;\n            }\n\n            //means its an end of string\n            if(inside_string == true && current_char == string_breaker_char){\n                inside_string = false;\n                string_breaker_char = '\\0';\n                continue;\n            }\n\n\n        }\n\n        CTextStack *possible_element = stack.substr(element,i,i+user_data->first_token_size);\n\n        if(!user_data->case_sensitive){\n            stack.self_lower(possible_element);\n        }\n\n        if(strcmp(possible_element->rendered_text,user_data->first_token) == 0){\n            found = true;\n            stack.format(mensage,\"%d,\",current_line+1);\n        }\n        stack.free(possible_element);\n\n\n    }\n    if(!found){\n        stack.free(mensage);\n        stack.free(element);\n        return;\n    }\n\n    stack.self_substr(mensage,0,-2);\n    stack.format(mensage,\"]\\n\");\n    interface.print(&interface, mensage->rendered_text);\n\n    stack.free(mensage);\n    stack.free(element);\n\n\n}\n\nvoid execute_the_search(UserData *user_data){\n    interface.print(&interface,\"-------------------Occurrences------------------\\n\");\n    if(user_data->type_of_source == DTW_FILE_TYPE){\n        execute_search_for_file(user_data,user_data->source);\n        return;\n    }\n    //VOID\n    DtwStringArray *content = dtw_list_files_recursively(user_data->source,DTW_CONCAT_PATH);\n    for(int i = 0; i < content->size; i++){\n        execute_search_for_file(user_data,content->strings[i]);\n    }\n    content->free(content);\n\n\n}"
	}, {
		"action":	"write",
		"source":	"src/replace.c",
		"content":	"//\n// Created by mateusmoutinho on 27/07/23.\n//\n\nCTextStack * execute_replace_for_file(UserData *user_data,char *filename){\n\n    char *content = dtw_load_string_file_content(filename);\n\n    if(!content){\n        return NULL;\n    }\n\n    CTextStack * element = newCTextStack_string(content);\n    CTextStack *new_element = newCTextStack_string_empty();\n\n    free(content);\n\n    bool found = false;\n    bool inside_string = false;\n    char string_breaker_char = '\\0';\n\n    for(int i =0; i < element->size; i++){\n        char current_char = element->rendered_text[i];\n\n\n        if(user_data->ignore_strings){\n\n            //means its inside and its an scape scape\n            if(inside_string  == true && current_char =='\\\\'){\n                i+=1;\n                stack.format(new_element,\"%c\",current_char);\n                continue;\n            }\n\n            //means its inside string\n            if(inside_string  == true && current_char != string_breaker_char){\n                stack.format(new_element,\"%c\",current_char);\n                continue;\n            }\n\n\n            //means its an start of string\n            if(inside_string == false && (current_char == '\"' || current_char == '\\'') ){\n                string_breaker_char = current_char;\n                inside_string = true;\n                stack.format(new_element,\"%c\",current_char);\n                continue;\n            }\n\n            //means its an end of string\n            if(inside_string == true && current_char == string_breaker_char){\n                inside_string = false;\n                string_breaker_char = '\\0';\n                stack.format(new_element,\"%c\",current_char);\n                continue;\n            }\n\n\n        }\n\n        CTextStack *possible_element = stack.substr(element,i,i+user_data->first_token_size);\n\n        if(!user_data->case_sensitive){\n            stack.self_lower(possible_element);\n        }\n\n        if(strcmp(possible_element->rendered_text,user_data->first_token) == 0){\n            found = true;\n            stack.format(new_element,\"%s\",user_data->second_token);\n            i+=user_data->second_token_size;\n        }\n        else{\n            stack.format(new_element,\"%c\",current_char);\n        }\n        stack.free(possible_element);\n\n\n    }\n    if(!found){\n        stack.free(element);\n        stack.free(new_element);\n        return NULL;\n    }\n\n\n    stack.free(element);\n    return  new_element;\n\n}\nvoid generated_transaction_backup(DtwTransaction *transaction){\n\n    bool store_backup = interface.ask_option(&interface,\"store backup?\",\"no | yes\");\n    if(!store_backup) {\n        return;\n    }\n\n    char *backup_file_path;\n\n    while(true){\n        char *not_formated_backup_file = interface.ask_string(&interface,\"type the name of your backup\",CLI_TRIM);\n        CTextStack *backup_modifed = newCTextStack_string_empty();\n        stack.format(backup_modifed, \"%s.replacer\", not_formated_backup_file);\n        free(not_formated_backup_file);\n\n        if(dtw_entity_type(backup_modifed->rendered_text) != DTW_NOT_FOUND){\n            CTextStack *already_exist_mensage = newCTextStack_string_empty();\n            stack.format(already_exist_mensage,\"file: %s already exist\",backup_modifed->rendered_text);\n            interface.warning(&interface,already_exist_mensage->rendered_text);\n            stack.free(already_exist_mensage);\n            stack.free(backup_modifed);\n            continue;\n        }\n        backup_file_path = strdup(backup_modifed->rendered_text);\n        stack.free(backup_modifed);\n        break;\n    }\n\n\n    DtwTransaction *backup_transaction = newDtwTransaction();\n    for(int i = 0; i < transaction->size; i++) {\n        char *current_file_path = transaction->actions[i]->source;\n        char *content = dtw_load_string_file_content(current_file_path);\n        backup_transaction->write_string(backup_transaction,current_file_path,content);\n        free(content);\n    }\n\n    backup_transaction->dumps_transaction_to_json_file(backup_transaction,backup_file_path);\n    backup_transaction->free(backup_transaction);\n\n}\n\nvoid execute_the_replace(UserData *user_data){\n\n    DtwTransaction *transaction = newDtwTransaction();\n\n    if(user_data->type_of_source == DTW_FILE_TYPE){\n        CTextStack *replaced_text = execute_replace_for_file(user_data,user_data->source);\n        if(replaced_text){\n            transaction->write_string(transaction,user_data->source,replaced_text->rendered_text);\n            stack.free(replaced_text);\n        }\n    }\n    else{\n        DtwStringArray *content = dtw_list_files_recursively(user_data->source,DTW_CONCAT_PATH);\n        for(int i = 0; i < content->size; i++){\n            char *filename = content->strings[i];\n            if(dtw_ends_with(filename,\".replacer\")){\n                continue;\n            }\n            CTextStack *replaced_text =execute_replace_for_file(user_data,filename);\n            if(replaced_text){\n                transaction->write_string(transaction,filename,replaced_text->rendered_text);\n                stack.free(replaced_text);\n            }\n        }\n        content->free(content);\n\n    }\n\n    CliInterface  anInterface = newCliInterface();\n    if(!transaction->size){\n        anInterface.warning(&anInterface,\"nothing to replace\\n\");\n        transaction->free(transaction);\n        return;\n    }\n    generated_transaction_backup(transaction);\n\n    anInterface.warning(&anInterface,\"The Following files will be modified\\n\");\n    for(int i = 0; i < transaction->size; i++){\n        CTextStack  *file = newCTextStack_string_empty();\n        stack.format(file,\"file: %s\\n\",transaction->actions[i]->source);\n        anInterface.warning(&anInterface,file->rendered_text);\n        stack.free(file);\n    }\n\n\n\n\n}"
	}]