[{
		"action":	"write",
		"source":	"dependencies2/CTextEngine.h",
		"content":	"/*\nMIT License\n\nCopyright (c) 2023 OUI\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n#ifndef CTEXTENGINE_H\n#define CTEXTENGINE_H\n\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n\n\n\n\n#define CTEXT_BY_OWNESHIP 1\n#define CTEXT_BY_COPY 2\n#define CTEXT_BY_REFERENCE 3\n\n//\n// Created by jurandi on 18-04-2023.\n//\n#define CTEXT_HTML \"html\"\n#define CTEXT_BODY \"body\"\n#define CTEXT_DIV \"div\"\n#define CTEXT_H1 \"h1\"\n#define CTEXT_H2 \"h2\"\n#define CTEXT_H3 \"h3\"\n#define CTEXT_H4 \"h4\"\n#define CTEXT_H5 \"h5\"\n#define CTEXT_H6 \"h6\"\n#define CTEXT_P \"p\"\n#define CTEXT_SPAN \"span\"\n#define CTEXT_A \"a\"\n#define CTEXT_IMG \"img\"\n#define CTEXT_INPUT \"input\"\n#define CTEXT_BUTTON \"button\"\n#define CTEXT_TABLE \"table\"\n#define CTEXT_TR \"tr\"\n#define CTEXT_TD \"td\"\n#define TH \"th\"\n#define CTEXT_THEAD \"thead\"\n#define CTEXT_TBODY \"tbody\"\n#define CTEXT_TFOOT \"tfoot\"\n#define CTEXT_UL \"ul\"\n#define CTEXT_LI \"li\"\n#define CTEXT_OL \"ol\"\n#define CTEXT_FORM \"form\"\n#define CTEXT_LABEL \"label\"\n#define CTEXT_SELECT \"select\"\n#define CTEXT_OPTION \"option\"\n#define CTEXT_TEXTAREA \"textarea\"\n#define CTEXT_SCRIPT \"script\"\n#define CTEXT_STYLE \"style\"\n#define CTEXT_META \"meta\"\n#define CTEXT_LINK \"link\"\n#define CTEXT_HEAD \"head\"\n#define CTEXT_BASE \"base\"\n#define CTEXT_BR \"br\"\n#define CTEXT_HR \"hr\"\n#define CTEXT_TITLE \"title\"\n#define CTEXT_IFRAME \"iframe\"\n#define CTEXT_NAV \"nav\"\n#define CTEXT_HEADER \"header\"\n#define CTEXT_FOOTER \"footer\"\n#define CTEXT_SECTION \"section\"\n#define CTEXT_ARTICLE \"article\"\n#define CTEXT_ASIDE \"aside\"\n#define CTEXT_DETAILS \"details\"\n#define CTEXT_SUMMARY \"summary\"\n#define CTEXT_DIALOG \"dialog\"\n#define MENU \"menu\"\n#define MENUITEM \"menuitem\"\n#define CTEXT_MAIN \"main\"\n#define CTEXT_CANVAS \"canvas\"\n#define CTEXT_AUDIO \"audio\"\n#define CTEXT_VIDEO \"video\"\n#define CTEXT_SOURCE \"source\"\n#define CTEXT_TRACK \"track\"\n#define CTEXT_EMBED \"embed\"\n#define CTEXT_PARAM \"param\"\n\n\n\n\n\n\n\n\n\n#define CTEXT_LINE_BREAKER \"\\n\"\n#define CTEXT_SEPARATOR \"   \"\n\n\ntypedef struct CTextStack{\n\n    char *rendered_text;\n    size_t rendered_text_alocation_size;\n    size_t size;\n\n    char *line_breaker;\n    char *separator;\n    int ident_level;\n\n}CTextStack;\n\nstruct CTextStack *newCTextStack(const char *line_breaker, const char *separator);\n\n\nstruct CTextStack *newCTextStack_string(const char *starter);\n\nstruct CTextStack *newCTextStack_string_getting_ownership(const char *starter);\n\nstruct CTextStack *newCTextStack_string_empty();\n\n\nvoid CTextStack_text(struct CTextStack *self, const char *text);\n\n\nvoid private_ctext_text_double_size_if_reachs(struct CTextStack *self);\n\n\nvoid CTextStack_segment_text(struct CTextStack *self, const char *text);\n\n\nvoid CTextStack_segment(struct CTextStack *self);\n\n\nvoid CTextStack_$open(struct CTextStack *self, const char *tag, const char *format, ...);\n\n\nvoid CTextStack_only$open(struct CTextStack *self, const char *tag, const char *format, ...);\n\n\nvoid CTextStack_auto$close(struct CTextStack *self, const char *tag, const char *format, ...);\n\n\nvoid CTextStack_format(struct CTextStack *self, const char *format, ...);\n\n\nvoid CTextStack_segment_format(struct CTextStack *self, const char *format, ...);\n\n\nvoid ctext_open(struct CTextStack *self, const char *tag);\n\n\nvoid ctext_close(struct CTextStack *self, const char *tag);\n\nvoid CTextStack_represent(struct CTextStack *self);\nvoid CTextStack_free(struct CTextStack *self);\n\n\nstruct CTextStack * CTextStack_clone(struct CTextStack *self);\n\n\nchar * CTextStack_self_transform_in_string_and_self_clear(struct CTextStack *self);\n\nvoid private_CTextStack_parse_ownership(struct CTextStack *self, struct CTextStack *new_string);\n\n\nvoid CTextStack_restart(struct CTextStack *self);\n\n\n//algorithm methods\n\nstruct CTextStack *CTextStack_substr(struct CTextStack *self, long starter, long end);\nvoid CTextStack_self_substr(struct CTextStack *self, long starter, long end);\n\n\nstruct CTextStack *CTextStack_pop(struct CTextStack *self, long starter, long end);\nvoid  CTextStack_self_pop(struct CTextStack *self, long starter, long end);\n\n\nstruct CTextStack *CTextStack_replace(struct CTextStack *self,const char *element, const char *element_to_replace);\nvoid CTextStack_self_replace(struct CTextStack *self,const char *element, const char *element_to_replace);\n\n\nstruct CTextStack *CTextStack_replace_long(struct CTextStack *self,const char *element, long element_to_replace);\nvoid CTextStack_self_replace_long(struct CTextStack *self,const char *element, long element_to_replace);\n\nstruct CTextStack *CTextStack_replace_double(struct CTextStack *self,const char *element, double element_to_replace);\nvoid CTextStack_self_replace_double(struct CTextStack *self,const char *element, double element_to_replace);\n\n\nstruct CTextStack *CTextStack_insert_at(struct CTextStack *self,long point, const char *element);\nvoid CTextStack_self_insert_at(struct CTextStack *self,long point, const char *element);\n\n\nlong CtextStack_index_of_char(struct  CTextStack *self,char element);\nlong CtextStack_index_of(struct  CTextStack *self,const char *element);\n\nbool CtextStack_starts_with(struct  CTextStack *self,const char *element);\nbool CtextStack_ends_with(struct  CTextStack *self,const char *element);\n\n\nstruct CTextStack *CTextStack_trim(struct CTextStack *self);\nvoid CTextStack_self_trim(struct CTextStack *self);\n\nstruct CTextStack *CTextStack_lower(struct CTextStack *self);\nvoid CTextStack_self_lower(struct CTextStack *self);\n\nstruct CTextStack *CTextStack_upper(struct CTextStack *self);\nvoid CTextStack_self_upper(struct CTextStack *self);\n\n\n\nstruct CTextStack *CTextStack_reverse(struct CTextStack *self);\nvoid CTextStack_self_reverse(struct CTextStack *self);\n\n\n\n\n\n\ntypedef struct CTextStackModule{\n\n    //admnistrative methods\n    void (*free)(struct CTextStack *self);\n    struct CTextStack *(*clone)(struct CTextStack *self);\n    void (*represent)(struct CTextStack *self);\n    char *(*self_transform_in_string_and_self_clear)(struct CTextStack *self);\n    void (*restart)(struct CTextStack *self);\n\n    //render methods\n    void (*text)(struct CTextStack *self, const char *element);\n\n    void (*segment_text)(struct CTextStack *self, const char *element);\n\n    void (*format)(struct CTextStack *self, const char *format, ...);\n\n    void (*segment)(struct CTextStack *self);\n\n    void (*segment_format)(struct CTextStack *self, const char *format, ...);\n\n    void (*$open)(struct CTextStack *self, const char *tag, const char *format,...);\n\n    void (*only$open)(struct CTextStack *self, const char *tag, const char *format,...);\n\n    void (*auto$close)(struct CTextStack *self, const char *tag, const char *format,...);\n\n    void (*open)(struct CTextStack *self, const char *tag);\n\n    void (*close)(struct CTextStack *self, const char *tag);\n\n\n    //algorithm methods\n    struct CTextStack * (*substr)(struct CTextStack *self, long starter, long end);\n    void  (*self_substr)(struct CTextStack *self, long starter, long end);\n\n\n    struct CTextStack *(*pop)(struct CTextStack *self, long starter, long end);\n    void(*self_pop)(struct CTextStack *self, long starter, long end);\n\n\n\n    struct CTextStack *(*insert_at)(struct CTextStack *self,long point, const char *element);\n    void (*self_insert_at)(struct CTextStack *self,long point, const char *element);\n\n    struct CTextStack *(*replace)(struct CTextStack *self,const char *element, const char *element_to_replace);\n    void (*self_replace)(struct CTextStack *self,const char *element, const char *element_to_replace);\n\n\n    struct CTextStack *(*replace_long)(struct CTextStack *self,const char *element, long element_to_replace);\n    void(*self_replace_long)(struct CTextStack *self,const char *element, long element_to_replace);\n\n\n    struct CTextStack *(*replace_double)(struct CTextStack *self,const char *element, double element_to_replace);\n    void (*self_replace_double)(struct CTextStack *self,const char *element, double element_to_replace);\n\n\n    struct CTextStack * (*lower)(struct CTextStack *self);\n    void(*self_lower)(struct CTextStack *self);\n\n    struct CTextStack * (*upper)(struct CTextStack *self);\n    void(*self_upper)(struct CTextStack *self);\n\n\n    struct CTextStack * (*reverse)(struct CTextStack *self);\n    void(*self_reverse)(struct CTextStack *self);\n\n    struct CTextStack * (*trim)(struct CTextStack *self);\n    void(*self_trim)(struct CTextStack *self);\n\n    bool (*starts_with)(struct CTextStack *self, const char *element);\n    bool (*ends_with)(struct CTextStack *self, const char *element);\n\n    long (*index_of)(struct CTextStack *self, const char *element);\n    long (*index_of_char)(struct CTextStack *self, char element);\n}CTextStackModule;\n\nCTextStackModule newCTextStackModule();\n\n\n\n\nlong private_CText_transform_index(long size, long value);\n\n\nvoid private_ctext_generate_formated_text(\n    struct CTextStack *stack,\n    const char *format,\n    va_list argptr\n    );\n\n\n\n//\n// Created by jurandi on 14-06-2023.\n//\nstruct CTextStack * newCTextStack(const char *line_breaker, const char *separator){\n    struct CTextStack *self = (struct CTextStack*)malloc(sizeof(struct CTextStack));\n    self->rendered_text = (char*)malloc(2);\n    strcpy(self->rendered_text,\"\\0\");\n    self->rendered_text_alocation_size = 2;\n    self->size = 0;\n    self->ident_level = 0;\n    self->line_breaker = strdup(line_breaker);\n    self->separator = strdup(separator);\n\n\n    return self;\n}\n\nstruct CTextStack *newCTextStack_string(const char *starter){\n    CTextStack *self = newCTextStack(\"\",\"\");\n    if(starter){\n        CTextStack_format(self,\"%s\", starter);\n    }\n    return self;\n}\n\nstruct CTextStack *newCTextStack_string_getting_ownership(const char *starter){\n    CTextStack *self = newCTextStack(\"\",\"\");\n    free(self->rendered_text);\n    self->rendered_text = (char*)starter;\n    self->size = strlen(starter);\n    self->rendered_text_alocation_size = self->size;\n    return self;\n}\nstruct CTextStack *newCTextStack_string_empty(){\n    return  newCTextStack(\"\",\"\");\n}\n\n\n\n\n\n\n\n\nchar * CTextStack_self_transform_in_string_and_self_clear(struct CTextStack *self){\n    free(self->line_breaker);\n    free(self->separator);\n    char *result = self->rendered_text;\n    free(self);\n    return result;\n}\n\nvoid private_CTextStack_parse_ownership(struct CTextStack *self, struct CTextStack *new_stack){\n\n    free(self->line_breaker);\n    free(self->separator);\n    free(self->rendered_text);\n\n    self->rendered_text_alocation_size = new_stack->rendered_text_alocation_size;\n    self->size = new_stack->size;\n    self->ident_level = new_stack->ident_level;\n\n\n    self->line_breaker = new_stack->line_breaker;\n    self->separator = new_stack->separator;\n    self->rendered_text = new_stack->rendered_text;\n    free(new_stack);\n\n}\nvoid CTextStack_restart(struct CTextStack *self){\n    free(self->rendered_text);\n    self->rendered_text = (char*)malloc(2);\n    strcpy(self->rendered_text,\"\\0\");\n    self->rendered_text_alocation_size = 2;\n    self->size = 0;\n    self->ident_level = 0;\n}\n\nvoid CTextStack_represent(struct CTextStack *self){\n    printf(\"%s\\n\",self->rendered_text);\n}\n\n\nvoid CTextStack_free(struct CTextStack *self){\n    free(self->line_breaker);\n    free(self->separator);\n    free(self->rendered_text);\n    free(self);\n}\n\nstruct CTextStack * CTextStack_clone(struct CTextStack *self){\n    CTextStack *new_stack = newCTextStack(self->line_breaker,self->separator);\n    new_stack->ident_level = self->ident_level;\n    CTextStack_text(new_stack,self->rendered_text);\n    return new_stack;\n}\n\n\n\n\nstruct CTextStack * CTextStack_substr(struct CTextStack *self, long starter, long end){\n\n    CTextStack *new_element = newCTextStack(self->line_breaker,self->separator);\n    new_element->ident_level = self->ident_level;\n    long formated_starter = private_CText_transform_index(self->size, starter);\n    long formated_end = private_CText_transform_index(self->size, end);\n\n    if(formated_starter == formated_end){\n        CTextStack_format(new_element,\"%c\",self->rendered_text[formated_starter]);\n        return new_element;\n    }\n\n    for(long i =formated_starter; i < formated_end; i++){\n        CTextStack_format(new_element,\"%c\",self->rendered_text[i]);\n    }\n\n    return new_element;\n\n}\n\nvoid CTextStack_self_substr(struct CTextStack *self, long starter, long end){\n    CTextStack *new_stack = CTextStack_substr(self,starter,end);\n    private_CTextStack_parse_ownership(self,new_stack);\n\n}\n\n\nstruct CTextStack *CTextStack_replace(struct CTextStack *self,const char *element, const char *element_to_replace){\n\n    CTextStack *new_element = newCTextStack(self->line_breaker,self->separator);\n    new_element->ident_level = self->ident_level;\n\n    long element_size = (long)strlen(element);\n    for(long i = 0; i < self->size;i++){\n        CTextStack  *possible_ocurrence  = CTextStack_substr(self,i,i+element_size);\n\n        if(strcmp(possible_ocurrence->rendered_text,element)== 0){\n            CTextStack_text(new_element,element_to_replace);\n            i+=element_size -1;\n        }\n\n        else{\n            CTextStack_format(new_element,\"%c\",self->rendered_text[i]);\n        }\n\n        CTextStack_free(possible_ocurrence);\n\n    }\n    return new_element;\n}\n\nvoid CTextStack_self_replace(struct CTextStack *self,const char *element, const char *element_to_replace){\n    CTextStack  *new_stack = CTextStack_replace(self,element,element_to_replace);\n    private_CTextStack_parse_ownership(self,new_stack);\n}\n\n\nstruct CTextStack *CTextStack_replace_long(struct CTextStack *self,const char *element, long element_to_replace){\n    char num_conversion[20] = {0};\n    sprintf(num_conversion,\"%ld\",element_to_replace);\n    return CTextStack_replace(self,element,num_conversion);\n}\n\n\nvoid CTextStack_self_replace_long(struct CTextStack *self,const char *element, long element_to_replace){\n    CTextStack  *new_stack = CTextStack_replace_long(self,element,element_to_replace);\n    private_CTextStack_parse_ownership(self,new_stack);\n}\n\n\nstruct CTextStack *CTextStack_replace_double(struct CTextStack *self,const char *element, double element_to_replace){\n    CTextStack  *num_formated = newCTextStack_string_empty();\n    CTextStack_format(num_formated,\"%f\",element_to_replace);\n    CTextStack  *result = CTextStack_replace(self,element,num_formated->rendered_text);\n    CTextStack_free(num_formated);\n    return result;\n}\n\n\nvoid CTextStack_self_replace_double(struct CTextStack *self,const char *element, double element_to_replace){\n    CTextStack  *new_stack = CTextStack_replace_double(self,element,element_to_replace);\n    private_CTextStack_parse_ownership(self,new_stack);\n}\n\n\n\nlong CtextStack_index_of(struct  CTextStack *self,const char *element){\n    long element_size = (long)strlen(element);\n    for(int i = 0; i < self->size; i++){\n        CTextStack  *possible_element = CTextStack_substr(self,i,i+element_size);\n        if(strcmp(possible_element->rendered_text,element) == 0){\n            CTextStack_free(possible_element);\n            return i;\n        }\n        CTextStack_free(possible_element);\n\n    }\n    return -1;\n}\n\n\nlong CtextStack_index_of_char(struct  CTextStack *self,char element){\n    for(int i = 0; i < self->size; i++) {\n        if(self->rendered_text[i] == element){\n            return i;\n        }\n    }\n    return -1;\n}\nbool CtextStack_starts_with(struct  CTextStack *self,const char *element){\n    long element_size = strlen(element);\n    CTextStack  *separated = CTextStack_substr(self,0,element_size);\n    if(strcmp(separated->rendered_text,element) == 0){\n        CTextStack_free(separated);\n        return true;\n    }\n    CTextStack_free(separated);\n    return false;\n}\n\nbool CtextStack_ends_with(struct  CTextStack *self,const char *element){\n    long element_size = strlen(element);\n    CTextStack  *separated = CTextStack_substr(self,self->size -element_size,-1);\n\n    if(strcmp(separated->rendered_text,element) == 0){\n        CTextStack_free(separated);\n        return true;\n    }\n    CTextStack_free(separated);\n    return false;\n}\n\n\n\nstruct CTextStack *CTextStack_lower(struct CTextStack *self){\n    CTextStack *new_element = newCTextStack(self->line_breaker,self->separator);\n    new_element->ident_level = self->ident_level;\n    for(long i =0; i < self->size; i++){\n        char current = self->rendered_text[i];\n        CTextStack_format(new_element,\"%c\",tolower(current));\n    }\n    return new_element;\n}\n\nvoid CTextStack_self_lower(struct CTextStack *self){\n    CTextStack *new_stack = CTextStack_lower(self);\n    private_CTextStack_parse_ownership(self,new_stack);\n}\n\nstruct CTextStack *CTextStack_upper(struct CTextStack *self){\n    CTextStack *new_element = newCTextStack(self->line_breaker,self->separator);\n    new_element->ident_level = self->ident_level;\n    for(long i =0; i < self->size; i++){\n        char current = self->rendered_text[i];\n        CTextStack_format(new_element,\"%c\",toupper(current));\n    }\n    return new_element;\n}\n\n\nvoid CTextStack_self_upper(struct CTextStack *self){\n    CTextStack *new_stack = CTextStack_upper(self);\n    private_CTextStack_parse_ownership(self,new_stack);\n}\n\n\nstruct CTextStack *CTextStack_reverse(struct CTextStack *self){\n    CTextStack *new_element = newCTextStack(self->line_breaker,self->separator);\n    new_element->ident_level = self->ident_level;\n    for(long i = (long)self->size; i >= 0 ; i--){\n        CTextStack_format(new_element,\"%c\",self->rendered_text[i]);\n    }\n    return new_element;\n\n}\n\nvoid CTextStack_self_reverse(struct CTextStack *self){\n    CTextStack *new_stack = CTextStack_reverse(self);\n    private_CTextStack_parse_ownership(self,new_stack);\n}\n\n\n\nstruct CTextStack *CTextStack_pop(struct CTextStack *self, long starter, long end){\n    CTextStack *new_element = newCTextStack(self->line_breaker,self->separator);\n    new_element->ident_level = self->ident_level;\n    long formated_starter = private_CText_transform_index(self->size, starter);\n    long formated_end = private_CText_transform_index(self->size, end);\n\n    for(int i =0; i < self->size; i ++){\n        if(i >= formated_starter && i <= formated_end){\n            continue;\n        }\n        CTextStack_format(new_element,\"%c\",self->rendered_text[i]);\n    }\n    return new_element;\n}\n\n\nvoid  CTextStack_self_pop(struct CTextStack *self, long starter, long end){\n    CTextStack  *new_stack = CTextStack_pop(self, starter, end);\n    private_CTextStack_parse_ownership(self,new_stack);\n}\n\n\nstruct CTextStack *CTextStack_insert_at(struct CTextStack *self,long point, const char *element){\n\n    CTextStack *new_element = newCTextStack(self->line_breaker,self->separator);\n    new_element->ident_level = self->ident_level;\n\n    long converted_point = private_CText_transform_index(self->size, point);\n    for(long i = 0; i < converted_point; i++){\n        CTextStack_format(new_element,\"%c\",self->rendered_text[i]);\n    }\n    CTextStack_text(new_element,element);\n    for(long i = converted_point; i < self->size; i++){\n        CTextStack_format(new_element,\"%c\",self->rendered_text[i]);\n    }\n    return new_element;\n}\n\nvoid CTextStack_self_insert_at(struct CTextStack *self,long point, const char *element){\n    CTextStack  *new_stack = CTextStack_insert_at(self, point,element);\n    private_CTextStack_parse_ownership(self,new_stack);\n}\n\n\nstruct CTextStack *CTextStack_trim(struct CTextStack *self){\n\n    CTextStack  *invalid_elements = newCTextStack_string(\"\\t\\r\\n \");\n    long start_point = 0;\n    for(int i = 0; i < self->size; i ++){\n        char current_char =self->rendered_text[i];\n        long invalid_point = CtextStack_index_of_char(invalid_elements,current_char);\n        bool is_invalid = invalid_point != -1;\n        if(!is_invalid){\n            start_point = i;\n            break;\n        }\n    }\n    long end_point = -1;\n    for(long i = (long)self->size -1; i >= 0; i--){\n\n        char current_char =self->rendered_text[i];\n        long invalid_point = CtextStack_index_of_char(invalid_elements,current_char);\n        bool is_invalid = invalid_point != -1;\n        if(!is_invalid){\n            end_point = i+1;\n            break;\n        }\n    }\n    CTextStack_free(invalid_elements);\n    return CTextStack_substr(self,start_point,end_point);\n\n}\n\n\nvoid CTextStack_self_trim(struct CTextStack *self){\n    CTextStack  *new_stack = CTextStack_trim(self);\n    private_CTextStack_parse_ownership(self,new_stack);\n}\n\n\nvoid private_ctext_text_double_size_if_reachs(struct CTextStack *self){\n\n    while(self->size >= (self->rendered_text_alocation_size - 2)){\n        self->rendered_text_alocation_size  =  (self->rendered_text_alocation_size  * 2)+2;\n        self->rendered_text = (char*)(realloc(\n            self->rendered_text,self->rendered_text_alocation_size\n        ));\n    }\n}\n\nvoid CTextStack_text(struct CTextStack *self, const char *text){\n\n    if (!text || !text[0]) {\n        // Tratar caso de ponteiro nulo ou string vazia\n        return;\n    }\n\n    size_t text_size = strlen(text);\n\n    self->size += text_size;\n    private_ctext_text_double_size_if_reachs(self);\n\n    memcpy(\n            self->rendered_text + self->size - text_size,\n        text,\n        text_size\n    );\n    self->rendered_text[self->size] = '\\0';\n}\n\n\n\nvoid CTextStack_segment_text(struct CTextStack *self, const char *text){\n    CTextStack_segment(self);\n    CTextStack_text(self,text);\n}\n\n\nvoid CTextStack_format(struct CTextStack *self, const char *format, ...){\n    va_list  argptr;\n    va_start(argptr, format);\n    private_ctext_generate_formated_text(self,format,argptr);\n}\n\nvoid CTextStack_segment_format(struct CTextStack *self, const char *format, ...){\n    CTextStack_segment(self);\n    va_list  argptr;\n    va_start(argptr, format);\n    private_ctext_generate_formated_text(self,format,argptr);\n}\n\n\nvoid CTextStack_segment(struct CTextStack *self){\n\n    CTextStack_text(self,self->line_breaker);\n\n    for(int i=0;i<self->ident_level;i++){\n        CTextStack_text(self,self->separator);\n\n    }\n\n\n}\n\nvoid CTextStack_$open(struct CTextStack *self, const char *tag, const char *format, ...){\n    CTextStack_segment(self);\n    CTextStack_format(self, \"%c\",'<');\n    CTextStack_text(self,tag);\n\n\n    if(format!=NULL){\n        CTextStack_format(self, \"%c\",' ');\n\n        va_list  argptr;\n        va_start(argptr, format);\n        private_ctext_generate_formated_text(self,format,argptr);\n    }\n    CTextStack_format(self, \"%c\",'>');\n\n\n    self->ident_level += 1;\n}\n\nvoid CTextStack_only$open(struct CTextStack *self, const char *tag, const char *format, ...){\n    CTextStack_segment(self);\n    CTextStack_format(self, \"%c\",'<');\n\n    CTextStack_text(self,tag);\n\n\n    if(format!=NULL){\n        CTextStack_format(self, \"%c\",' ');\n        va_list  argptr;\n        va_start(argptr, format);\n        private_ctext_generate_formated_text(self,format,argptr);\n    }\n    CTextStack_format(self, \"%c\",'>');\n\n\n}\n\nvoid CTextStack_auto$close(struct CTextStack *self, const char *tag, const char *format, ...){\n    CTextStack_segment(self);\n    CTextStack_format(self, \"%c\",'<');\n\n    CTextStack_text(self,tag);\n\n\n    if(format!=NULL){\n        CTextStack_format(self, \"%c\",' ');\n\n        va_list  argptr;\n        va_start(argptr, format);\n        private_ctext_generate_formated_text(self,format,argptr);\n    }\n    CTextStack_text(self,\"/>\");\n\n}\n\nvoid ctext_open(struct CTextStack *self, const char *tag){\n    if(tag ==  NULL){\n\n        self->ident_level += 1;\n        return;\n    }\n    CTextStack_$open(self, tag, NULL);\n}\n\n\n\n\nvoid ctext_close(struct CTextStack *self, const char *tag){\n\n    if(tag==NULL){\n        self->ident_level -= 1;\n\n        return;\n    }\n    self->ident_level -= 1;\n    CTextStack_segment(self);\n\n\n    CTextStack_text(self,\"</\");\n    CTextStack_text(self,tag);\n    CTextStack_format(self, \"%c\",'>');\n\n}\n\n\n\n\n\nCTextStackModule newCTextStackModule(){\n    struct CTextStackModule self = {0};\n\n    self.text = CTextStack_text;\n    self.segment_text = CTextStack_segment_text;\n    self.format = CTextStack_format;\n    self.segment = CTextStack_segment;\n    self.segment_format = CTextStack_segment_format;\n    self.$open = CTextStack_$open;\n    self.only$open =CTextStack_only$open;\n    self.auto$close = CTextStack_auto$close;\n    self.open = ctext_open;\n    self.close = ctext_close;\n    self.free =  CTextStack_free;\n    self.clone = CTextStack_clone;\n    self.represent = CTextStack_represent;\n    self.self_transform_in_string_and_self_clear = CTextStack_self_transform_in_string_and_self_clear;\n    self.restart = CTextStack_restart;\n    self.substr = CTextStack_substr;\n    self.self_substr =CTextStack_self_substr;\n\n    self.pop = CTextStack_pop;\n    self.self_pop =CTextStack_self_pop;\n\n    self.replace = CTextStack_replace;\n    self.self_replace = CTextStack_self_replace;\n\n    self.replace_long = CTextStack_replace_long;\n    self.self_replace_long =CTextStack_self_replace_long;\n\n\n    self.replace_double = CTextStack_replace_double;\n    self.self_replace_double =CTextStack_self_replace_double;\n\n    self.insert_at = CTextStack_insert_at;\n    self.self_insert_at  = CTextStack_self_insert_at;\n\n\n    self.index_of = CtextStack_index_of;\n    self.index_of_char = CtextStack_index_of_char;\n\n    self.lower = CTextStack_lower;\n    self.self_lower = CTextStack_self_lower;\n\n    self.upper = CTextStack_upper;\n    self.self_upper = CTextStack_self_upper;\n\n    self.starts_with = CtextStack_starts_with;\n    self.ends_with = CtextStack_ends_with;\n\n    self.reverse = CTextStack_reverse;\n    self.self_reverse = CTextStack_self_reverse;\n\n    self.trim = CTextStack_trim;\n    self.self_trim = CTextStack_self_trim;\n\n\n    return self;\n}\n\n\n\n\nvoid private_ctext_generate_formated_text(\n        struct CTextStack *stack,const char *format,va_list argptr){\n    long  text_size = strlen(format);\n\n    int i;\n    for(i =0;i < text_size -1 ;i++){\n\n        char single_test[3] = {format[i],format[i+1],'\\0'};\n        char double_test[4] = {0};\n\n\n        if(i < text_size -2){\n            strcpy(double_test,single_test);\n            double_test[2] = format[i+2];\n            double_test[3] = '\\0';\n\n        }\n\n        if(strcmp(single_test,\"%d\") == 0) {\n            char result[20] ={0};\n            sprintf(result,\"%ld\", va_arg(argptr,long));\n            CTextStack_text(stack,result);\n            i+=1;\n            continue;\n        }\n\n        if(strcmp(single_test,\"%f\") == 0) {\n            char result_text[20]= {0};\n\n            sprintf(result_text,\"%lf\", va_arg(argptr,double ));\n\n            for(int t = 18; t > 0; t--){\n                char current_char = result_text[t];\n                if(current_char != '0' && current_char != '\\0'){\n\n                    if(current_char == '.'){\n                        result_text[t+2]  = '\\0';\n                    }\n                    else{\n                        result_text[t+1]  = '\\0';\n                    }\n\n                    break;\n                }\n            }\n            CTextStack_text(stack,result_text);\n            i+=1;\n            continue;\n        }\n\n        else if(strcmp(single_test,\"%c\") == 0){\n            char result = va_arg(argptr,int);\n            char element[2] = {result,'\\0'};\n            CTextStack_text(stack,element);\n            i+=1;\n            continue;\n        }\n\n\n        else if(strcmp(single_test,\"%b\") == 0){\n            bool value = va_arg(argptr,int);\n            if(value){\n                CTextStack_text(stack,\"true\");\n            }else{\n                CTextStack_text(stack,\"false\");\n            }\n            i+=1;\n            continue;\n        }\n\n        else if(strcmp(double_test,\"%sc\") == 0){\n            char *value = va_arg(argptr,char*);\n            CTextStack_text(stack,value);\n            free(value);\n            i+=2;\n            continue;\n        }\n\n        else if(strcmp(single_test,\"%s\") == 0){\n            const char *value = va_arg(argptr,const char*);\n            CTextStack_text(stack,value);\n            i+=1;\n            continue;\n        }\n        else if(strcmp(double_test,\"%tc\") == 0){\n            struct CTextStack *new_stack = (struct  CTextStack*)va_arg(argptr,void *);\n            char *result = CTextStack_self_transform_in_string_and_self_clear(new_stack);\n            CTextStack_text(stack,result);\n            free(result);\n            i+=2;\n            continue;\n        }\n\n        else if(strcmp(single_test,\"%t\") == 0){\n            struct CTextStack *new_stack = (struct  CTextStack*)va_arg(argptr,void *);\n            CTextStack_text(stack,new_stack->rendered_text);\n            i+=1;\n            continue;\n        }\n\n        char element[2] = {format[i],'\\0'};\n        CTextStack_text(stack,element);\n\n        }\n\n\n\n    if(text_size > 0 && text_size> i){\n        char element[2] = {format[text_size-1],'\\0'};\n        CTextStack_text(stack,element);\n    }\n\n    va_end(argptr);\n}\n\n\nlong private_CText_transform_index(long size , long value){\n    long formated_value = value;\n\n    if(formated_value >= size){\n        formated_value = size;\n    }\n\n    if(formated_value  < 0){\n        formated_value = size + (formated_value +1);\n    }\n    if(formated_value <0){\n        formated_value = 0;\n    }\n    return formated_value;\n}\n\n#endif // CTEXTENGINE_H"
	}]